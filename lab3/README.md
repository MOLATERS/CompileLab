# 编译原理实验三

## 实验环境

WSL 版本: 2.1.5.0  内核版本: 5.15.146.1-2

## 实验功能

在词法分析、语法分析和语义分析程序的基础上，将C−−源代码翻译为中间代码。

## 实验亮点

实验中使用链表`interCodesList`结构来存储三地址的表示，用来生成中间代码，数据结构的定义如下所示：

```c
typedef struct _interCodes {
    pInterCode code;
    pInterCodes prev, next;
} InterCodes;
```

通过这个数据定义能够更加有效的进行中间代码的遍历操作，并最终生成给定c--文法的中间优化过的代码。

实验3通过实验2进行语义分析生成的符号表来进行操作，使用实验2中用到的栈结构，由于只需要所有的可用的符号表来查找对应ID的性质和参数，所以在执行语义分析的时候不进行`pop`和`push`操作，也就构成了符号表的结构，提升了空间利用率和查找效率，虽然有了发生冲突的风险，但是在进行测试用例的时候性能明显上升。

进行函数类型的ID的参数列表的时候，使用链表的方式来进行存储，数据结构定义如下所示：

```c
typedef struct _arg {
    pOperand op;
    pArg next;
} Arg;
```

---

然后来进行一次中间代码生成的跟踪运行，讲解在跟踪运行的时候的实现方式：（测试用例2）

以测试2中的`fact`函数翻译为例，首先分析`fact`和其后的`CompSt`内容，然后递归的去查找`Stmt`的内容，在其子模块`StmtList`中发现出现了`IF ELSE`的类型语句，然后通过类型的选择语句，进入`IF ELSE`的处理模块中。先通过两个新创建的`label`位置创建一个`Cond`语句，最后得到的是一个`IF GOTO`语句，然后将第二个label放在该语句的正下方，如果失败就跳转到新的位置，然后最后通过第三个`label`来做到分支语句结束后跳转到正常的位置继续执行；在执行语句翻译的时候，是通过临时变量的方式来传递中间值，并通过递归的方式控制临时变量的赋值操作，这样就能通过从叶节点到根结点反向的方式来执行代码生成。最后更新`interCodeList`，继续分析下一个`Stmt`内容。

## 程序构建

测试单个部分：

```shell
bash test.sh 1 //或者是2
```

测试全部部分：

```c
bash test.sh 
```

测试结果会显现在output文件夹，按照ir后缀名存储。

测试成功截图如下所示：（测试用例1）

<img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/pictureimage-20240511151820206.png" alt="image-20240511151820206" style="zoom:50%;" />

测试用例的最终结果在虚拟机上成功运行结果如下所示：

<img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/pictureimage-20240511151937535.png" alt="image-20240511151937535" style="zoom:50%;" />

## 实验总结

实验三让我深刻体会到了编译器设计中的种种复杂性和挑战。通过优化中间代码生成和符号表管理，我意识到了在实际工程中，一个高效的编译器不仅需要正确地将源代码转换为目标代码，还需要考虑性能和可维护性等方面的问题。在实验中，我发现了链表结构在存储中间代码时的便利之处，它不仅使得代码的遍历更加高效，还有助于优化代码生成过程。同时，通过使用栈来管理符号表，我意识到了在实践中如何权衡空间利用率和查找效率之间的关系。在处理函数参数列表时，选择了链表存储结构，这为后续的代码生成提供了更大的灵活性。同时，在理解和实现中间代码生成的过程中，我深深感受到了递归的力量，尤其是在处理复杂的控制流语句时。

最后，通过整个实验的过程，我不仅学到了编译原理相关知识，还培养了解决问题的能力。我相信这些经验将对我的未来学习和工作产生积极的影响。