# 编译原理实验二

## 需要调试的错误类型

错误类型1:变量在使用时未经定义。

错误类型3:变量出现重复定义或变量与前面定义过的结构体名字重复。

错误类型5:赋值号两边的表达式类型不匹配。 

错误类型6:赋值号左边出现一个只有右值的表达式。

错误类型7:操作数类型不匹配或操作数类型与操作符不匹配(例如整型变量与数组变量相加减,或数组(或结构体)变量与结构体(或数组)变量相加减)。

错误类型10:对非数组型变量使用数组访问操作符。

错误类型12:数组访问操作符“[...]”中出现非整数(例如a[1.5])。

# 实验报告

## 实验环境

WSL 版本: 2.1.5.0  内核版本: 5.15.146.1-2

## 实验功能

- 巩固对语义分析的基本功能和原理的认识。
- 能够基于语法指导翻译的知识进行语义分析。
- 理解并处理语义分析中的异常和错误。

在词法分析和语法分析程序的基础上编写一个程序,对C--源代码进行语义分析和类型检查,并打印分析结果。

## 实验亮点

### 数据结构定义

![b40e12291fe59159c1622c849793b30](https://typora-slater.oss-cn-beijing.aliyuncs.com/pictureb40e12291fe59159c1622c849793b30.jpg)

数据结构中使用链栈的结构来划分各个语义成分的作用域，在每一个作用域中，使用符号表来进行符号名的冲突检测，如果两个符号的名字映射到同一个表的域内，就会曝出类型冲突的错误类型；在一个域内，将不同的类型通过链表的方式连接在一起，能够进行类型之间的相互关系的管理。

### 语义分析部分

在进行语义分析时，对语法树中的每一种可能的结点进行了扫描和检测，首先使用之前通过词法分析和语法分析构成的语法树，通过先序遍历的方式来进行结点的遍历操作，通过递归的方式开始扫描。

在扫描每个语法树的结点的过程中，需要比较的分别为：

1. 当前结点（以及可能出现的后继结点）的名字，当前结点的类型。

​	在这里定义了`is_equal()`函数，用来比较两个类型是否一致。

2. 需要比较类型的名字是否冲突。

​	在这里定义了`conflict()`函数，用来比较同一个作用域下的名字是否冲突。

3. 比较赋值语句中的左右值的类型是否一致。同时也检查赋值号的左边是不是出现了一个只有右值的表达式。使用语句来判断一个结点是不是只有右值：

   ```c
   if (!strcmp(tchild->name, "FLOAT") || !strcmp(tchild->name, "INT"))
   ```

4. 检查数组操作的下标类型是否是`INT`类型，或者对非数组元素进行下标定位。

   检查一个结点是不是INT类型的代码比较简单:

   ```c
   else if (!p2 || p2->kind != INT_TYPE || p2->detail.basic_type != INT_TYPE)
   ```

   用这个方式来检查当前的结点元素是不是一个数组元素，访问是否合法：

   ```c
   if (p1 && p1->kind != ARRAY_TYPE)
   ```

## 程序构建

测试单个部分：

```shell
bash test.sh 1 # 使用错误号来指定使用的测试文件
```

测试全部部分：

```shell
bash test.sh # 测试全部的测试用例并输出结果
```

## 测试结果

![image-20240429220231341](https://typora-slater.oss-cn-beijing.aliyuncs.com/pictureimage-20240429220231341.png)

## 实验总结

在本次实验中，通过对语法树的细致分析，更清楚需要进行编译的代码所包含的结构以及需要考虑的各种错误处理。在此次实验中收益良多。